## Module Layout

- `table.rs`: adjacency table
  - Tree data structure on vector
  - Inode allocation by `MIN_ID + index`
  - Not `MT-Safe`
- `handle.rs`: Mount Handle
  - NewType wrapper for dropping
- `adapter` module: adapter between internal data structure(tree-like) and `libfuse`
  - `error.rs`: a centralized way to handle error
  - `fuse.rs`: adaptor between internal data structure and `libfuse`
  - `reply.rs`: collection of constructor for replay from `libfuse`
  - `handle.rs`: file handle table
  - `template.rs`: A NewType wrapper to force user explicitly clone(`as_filesystem`) filesystem
- `entry` module: collection of single file
  - `tar.rs`: a NewType wrapper for `Tree<Entry>`
  - `ro.rs`: read only normal file(mapped from tar ball)
  - `rw.rs`: read/write normal file(in memory)
- `resource.rs`: Resource counter, much like `semaphore`
- `mkdtemp.rs`: a safe wrapper around `libc::mkdtemp`

## Prerequisite knowledge

### Filesystem in Userspace

> FUSE, or Filesystem in Userspace, is a software interface that allows non-privileged users to create their own file systems in Linux without modifying the kernel.  It acts as a bridge between the kernel's virtual filesystem layer and user-space programs.

Traditionally, we have to develop a dedicated kernel module for a filesystem.

FUSE workaround this problem by providing connection, to set up a FUSE, program need to...

1. acquire a FUSE connection(similar to unix socket).
2. poll the socket until a connection(similar to a new connection on tcp socket)
3. read that connection to acquire an OPCODE
4. follow OPCODE to parse the request

example of OPCODE: `READ`, `LOOKUP`, `OPEN`, `RMDIR`...

[list](https://github.com/libfuse/libfuse/blob/6476b1c3ccde2fc4e8755858c96debf55aa0574b/lib/fuse_lowlevel.c#L2619) of OPCODE

In this project, we use `fuse3`, which is a wrapper over `libfuse-sys`.

To get started, you can follow [main.rs](https://github.com/Sherlock-Holo/fuse3/blob/master/examples/src/memfs/main.rs) from `fuse3`'s example.

#### `INODE`

`INODE` is an id generate by filesystem, program providing that can set `INODE` to whatever you want, but make sure it's unique for same file(dictionary).

You can get inode with `stat`
```
❯ stat .
  File: .
  Size: 128             Blocks: 0          IO Block: 4096   directory
Device: 2ah/42d Inode: 13553287    Links: 1
Access: (0775/drwxrwxr-x)  Uid: ( 1000/   eason)   Gid: ( 1000/   eason)
Access: 2024-04-28 19:44:43.208376257 +0800
Modify: 2024-05-20 21:39:42.300855512 +0800
Change: 2024-05-20 21:39:42.300855512 +0800
 Birth: 2024-04-28 19:44:43.208376257 +0800
```

Note that zero `INODE` means unspecified(null in C's language). 

#### `File Handle`

In the context of filesystem of libc, you might be familiar with `file descriptor`, `file descriptor` is a `uint64` generate secquetially by kernel(unique for each process).

`File handle` is similar to `file descriptor`, but it sit between kernel and FUSE provider, generated by FUSE provider and unique for each FUSE connection.

When a file open, FUSE provider generate a `uint64`, and file handle is pass as parameter for later operations.

FUSE provider should implement a way to retrieve file's session by `file handle`.

> file's session includes `bytes readed`, `open flag`...

Note that zero `File Handle` means unspecified(null in C's language), generating a 0 `File Handle` is not allowed. 

#### OPCODE `READDIR`

> Read directory.

similar to what `ls -a` provide, list dictionary including `.` and `..`

parameters:
1. parent `INODE`(could be unspecified, unspecified is root)
2. offset 
3. size

return: list of file(dictionary)

example(ignore the fact that many file is missing):

```
❯ ls /
❯ ls -a /
.   ..   boot   etc   lib    lib64   media
```

| offset  | size  | output |
|  ----  | ----  | --- |
| 0  | 1 | `.` |
| 2 | 3 | `etc`, `lib`, `lib64` |

#### OPCODE `OPEN`

> Open a file. Open flags (with the exception of O_CREAT, O_EXCL, O_NOCTTY and O_TRUNC) are available in flags

parameters:
1. file `INODE`(could be unspecified, unspecified is root)
2. flag

return: File Handle

`O_CREAT` should be handle by kernel instead.

### mkdtemp

> See `man mkdtemp`
